{"version":3,"file":"geo-worker-ByCpZBgh.js","sources":["../node_modules/robust-predicates/esm/util.js","../node_modules/robust-predicates/esm/orient2d.js","../node_modules/point-in-polygon-hao/dist/esm/index.js","../node_modules/@turf/invariant/dist/esm/index.js","../node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js","../node_modules/quickselect/index.js","../node_modules/rbush/index.js","../src/geo-worker.ts"],"sourcesContent":["export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","import { orient2d } from 'robust-predicates';\n\nfunction pointInPolygon(p, polygon) {\n    var i;\n    var ii;\n    var k = 0;\n    var f;\n    var u1;\n    var v1;\n    var u2;\n    var v2;\n    var currentP;\n    var nextP;\n\n    var x = p[0];\n    var y = p[1];\n\n    var numContours = polygon.length;\n    for (i = 0; i < numContours; i++) {\n        ii = 0;\n        var contour = polygon[i];\n        var contourLen = contour.length - 1;\n\n        currentP = contour[0];\n        if (currentP[0] !== contour[contourLen][0] &&\n            currentP[1] !== contour[contourLen][1]) {\n            throw new Error('First and last coordinates in a ring must be the same')\n        }\n\n        u1 = currentP[0] - x;\n        v1 = currentP[1] - y;\n\n        for (ii; ii < contourLen; ii++) {\n            nextP = contour[ii + 1];\n\n            u2 = nextP[0] - x;\n            v2 = nextP[1] - y;\n\n            if (v1 === 0 && v2 === 0) {\n                if ((u2 <= 0 && u1 >= 0) || (u1 <= 0 && u2 >= 0)) { return 0 }\n            } else if ((v2 >= 0 && v1 <= 0) || (v2 <= 0 && v1 >= 0)) {\n                f = orient2d(u1, u2, v1, v2, 0, 0);\n                if (f === 0) { return 0 }\n                if ((f > 0 && v2 > 0 && v1 <= 0) || (f < 0 && v2 <= 0 && v1 > 0)) { k++; }\n            }\n            currentP = nextP;\n            v1 = v2;\n            u1 = u2;\n        }\n    }\n\n    if (k % 2 === 0) { return false }\n    return true\n}\n\nexport { pointInPolygon as default };\n","// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type\n    );\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n    );\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n      );\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport {\n  collectionOf,\n  containsNumber,\n  featureOf,\n  geojsonType,\n  getCoord,\n  getCoords,\n  getGeom,\n  getType\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport pip from \"point-in-polygon-hao\";\nimport { getCoord, getGeom } from \"@turf/invariant\";\nfunction booleanPointInPolygon(point, polygon, options = {}) {\n  if (!point) {\n    throw new Error(\"point is required\");\n  }\n  if (!polygon) {\n    throw new Error(\"polygon is required\");\n  }\n  const pt = getCoord(point);\n  const geom = getGeom(polygon);\n  const type = geom.type;\n  const bbox = polygon.bbox;\n  let polys = geom.coordinates;\n  if (bbox && inBBox(pt, bbox) === false) {\n    return false;\n  }\n  if (type === \"Polygon\") {\n    polys = [polys];\n  }\n  let result = false;\n  for (var i = 0; i < polys.length; ++i) {\n    const polyResult = pip(pt, polys[i]);\n    if (polyResult === 0) return options.ignoreBoundary ? false : true;\n    else if (polyResult) result = true;\n  }\n  return result;\n}\nfunction inBBox(pt, bbox) {\n  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n}\nvar turf_boolean_point_in_polygon_default = booleanPointInPolygon;\nexport {\n  booleanPointInPolygon,\n  turf_boolean_point_in_polygon_default as default\n};\n//# sourceMappingURL=index.js.map","\n/**\n * Rearranges items so that all items in the [left, k] are the smallest.\n * The k-th element will have the (k - left + 1)-th smallest value in [left, right].\n *\n * @template T\n * @param {T[]} arr the array to partially sort (in place)\n * @param {number} k middle index for partial sorting (as defined above)\n * @param {number} [left=0] left index of the range to sort\n * @param {number} [right=arr.length-1] right index\n * @param {(a: T, b: T) => number} [compare = (a, b) => a - b] compare function\n */\nexport default function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselect(arr, k, newLeft, newRight, compare);\n        }\n\n        const t = arr[k];\n        let i = left;\n        /** @type {number} */\n        let j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * @template T\n * @param {T} a\n * @param {T} b\n * @returns {number}\n */\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","/// <reference lib=\"webworker\" />\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport RBush, { type BBox } from 'rbush';\n\ntype PolygonFeature = {\n  type: 'Feature';\n  properties: { name: string; id: string };\n  geometry: { type: 'Polygon' | 'MultiPolygon'; coordinates: any };\n  bbox?: [number, number, number, number];\n};\n\ntype TreeItem = BBox & { idx: number };\n\nconst ctx = self as unknown as DedicatedWorkerGlobalScope;\nlet features: PolygonFeature[] = [];\nconst tree = new RBush<TreeItem>();\nlet lastSuburb: string | null = null;\n\nctx.addEventListener('message', (e) => {\n  const msg = e.data;\n  if (msg.type === 'build-index') {\n    features = msg.polygons as PolygonFeature[];\n    const items: TreeItem[] = [];\n    features.forEach((f, idx) => {\n      const b = f.bbox ?? computeBBox(f);\n      items.push({ minX: b[0], minY: b[1], maxX: b[2], maxY: b[3], idx });\n    });\n    tree.clear();\n    tree.load(items);\n    ctx.postMessage({ type: 'ready' });\n  }\n  if (msg.type === 'loc-update') {\n    const { coord, heading } = msg as { coord: {lng:number;lat:number}; heading?: number };\n    const hereSuburb = getSuburbAt(coord.lng, coord.lat);\n    if (hereSuburb) lastSuburb = hereSuburb;\n\n    const h = (typeof heading === 'number' && !Number.isNaN(heading)) ? heading : 0;\n    const norm = (a: number) => (a % 360 + 360) % 360;\n    const next = {\n      top: castUntilChange(coord, norm(h)),\n      bottom: castUntilChange(coord, norm(h + 180)),\n      left: castUntilChange(coord, norm(h - 90)),\n      right: castUntilChange(coord, norm(h + 90)),\n    } as const;\n\n    ctx.postMessage({ type: 'loc-result', suburbName: lastSuburb, nextDirs: next });\n  }\n});\n\nfunction computeBBox(f: PolygonFeature): [number, number, number, number] {\n  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n  const iterate = (coords: any[]) => {\n    for (const ring of coords) {\n      for (const [x, y] of ring) {\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n      }\n    }\n  };\n  if (f.geometry.type === 'Polygon') iterate(f.geometry.coordinates);\n  else for (const poly of f.geometry.coordinates) iterate(poly);\n  return [minX, minY, maxX, maxY];\n}\n\nfunction getSuburbAt(lng: number, lat: number): string | null {\n  const candidates = tree.search({ minX: lng, minY: lat, maxX: lng, maxY: lat });\n  for (const c of candidates) {\n    const feat = features[c.idx];\n    if (booleanPointInPolygon([lng, lat], feat as any)) return feat.properties.name;\n  }\n  return null;\n}\n\nfunction castUntilChange(coord: {lng:number;lat:number}, bearingDeg: number): { name: string|null; distM: number|null } {\n  const startName = getSuburbAt(coord.lng, coord.lat);\n  const stepM = 25;\n  const maxM = 10000; // 10 km window\n  let traveled = 0;\n  const rad = (bearingDeg * Math.PI) / 180;\n  const cosLat = Math.cos((coord.lat * Math.PI) / 180);\n  const dLngPerM = 1 / (111320 * cosLat);\n  const dLatPerM = 1 / 110540;\n  let lng = coord.lng;\n  let lat = coord.lat;\n  while (traveled <= maxM) {\n    lng += Math.sin(rad) * stepM * dLngPerM;\n    lat += Math.cos(rad) * stepM * dLatPerM;\n    traveled += stepM;\n    const name = getSuburbAt(lng, lat);\n    if (name && name !== startName) return { name, distM: traveled };\n  }\n  // Fallback: choose nearest suburb roughly along this bearing (centroid angle within 60Â°)\n  const candidates = features\n    .map((f, idx) => ({ f, idx, center: bboxCenter(f.bbox ?? computeBBox(f)) }))\n    .filter((c) => c.f.properties.name !== startName)\n    .map((c) => {\n      const brg = bearingDegBetween(coord, { lng: c.center[0], lat: c.center[1] });\n      const ang = angleDiff(bearingDeg, brg);\n      const dist = distanceToBBoxMeters(coord, c.f.bbox ?? computeBBox(c.f));\n      return { name: c.f.properties.name, ang, dist };\n    })\n    .filter((x) => x.ang <= 60)\n    .sort((a, b) => a.dist - b.dist);\n  if (candidates.length > 0) return { name: candidates[0].name, distM: candidates[0].dist };\n  return { name: null, distM: null };\n}\n\nfunction bboxCenter(b: [number, number, number, number]): [number, number] {\n  return [(b[0] + b[2]) / 2, (b[1] + b[3]) / 2];\n}\n\nfunction bearingDegBetween(a: {lng:number;lat:number}, b: {lng:number;lat:number}): number {\n  const y = Math.sin((b.lng - a.lng) * Math.PI/180) * Math.cos(b.lat * Math.PI/180);\n  const x = Math.cos(a.lat * Math.PI/180) * Math.sin(b.lat * Math.PI/180) -\n            Math.sin(a.lat * Math.PI/180) * Math.cos(b.lat * Math.PI/180) * Math.cos((b.lng - a.lng) * Math.PI/180);\n  const brng = Math.atan2(y, x) * 180/Math.PI;\n  return (brng + 360) % 360;\n}\n\nfunction angleDiff(a: number, b: number): number {\n  let d = Math.abs(a - b) % 360;\n  if (d > 180) d = 360 - d;\n  return d;\n}\n\nfunction distanceToBBoxMeters(p: {lng:number;lat:number}, b: [number, number, number, number]): number {\n  // Approximate planar distance to rectangle (clamp to edges)\n  const cosLat = Math.cos((p.lat * Math.PI) / 180);\n  const toMetersX = (lng: number) => (lng - p.lng) * 111320 * cosLat;\n  const toMetersY = (lat: number) => (lat - p.lat) * 110540;\n  const px = 0, py = 0;\n  const rx1 = toMetersX(b[0]);\n  const ry1 = toMetersY(b[1]);\n  const rx2 = toMetersX(b[2]);\n  const ry2 = toMetersY(b[3]);\n  const cx = clamp(px, Math.min(rx1, rx2), Math.max(rx1, rx2));\n  const cy = clamp(py, Math.min(ry1, ry2), Math.max(ry1, ry2));\n  return Math.hypot(px - cx, py - cy);\n}\n\nfunction clamp(v: number, lo: number, hi: number) { return Math.max(lo, Math.min(hi, v)); }\n\n\n"],"names":["epsilon","splitter","resulterrbound","sum","elen","e","flen","f","h","Q","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","estimate","i","vec","n","ccwerrboundA","ccwerrboundB","ccwerrboundC","B","C1","C2","D","u","orient2dadapt","ax","ay","bx","by","cx","cy","detsum","acxtail","acytail","bcxtail","bcytail","c","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","det","errbound","C1len","C2len","Dlen","orient2d","detleft","detright","pointInPolygon","p","polygon","ii","k","u1","v1","u2","v2","currentP","nextP","x","y","numContours","contour","contourLen","getCoord","coord","getGeom","geojson","booleanPointInPolygon","point","options","pt","geom","type","bbox","polys","inBBox","result","polyResult","pip","turf_boolean_point_in_polygon_default","quickselect","arr","left","right","compare","defaultCompare","m","z","s","sd","newLeft","newRight","t","j","swap","tmp","a","b","RBush","maxEntries","node","intersects","toBBox","nodesToSearch","child","childBBox","contains","data","tmpNode","item","createNode","equalsFn","path","indexes","parent","goingUp","index","findItem","items","height","N","M","calcBBox","N2","N1","multiSelect","right2","right3","level","minArea","minEnlargement","targetNode","area","bboxArea","enlargement","enlargedArea","isNode","insertPath","extend","splitIndex","newNode","minOverlap","bbox1","distBBox","bbox2","overlap","intersectionArea","compareMinX","compareNodeMinX","compareMinY","compareNodeMinY","xMargin","yMargin","leftBBox","rightBBox","margin","bboxMargin","siblings","destNode","minX","minY","maxX","maxY","children","stack","mid","ctx","features","tree","lastSuburb","msg","idx","computeBBox","heading","hereSuburb","getSuburbAt","norm","next","castUntilChange","iterate","coords","ring","poly","lng","lat","candidates","feat","bearingDeg","startName","stepM","maxM","traveled","rad","dLngPerM","dLatPerM","name","bboxCenter","brg","bearingDegBetween","ang","angleDiff","dist","distanceToBBoxMeters","d","cosLat","toMetersX","toMetersY","px","py","rx1","ry1","rx2","ry2","clamp","v","lo","hi"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}